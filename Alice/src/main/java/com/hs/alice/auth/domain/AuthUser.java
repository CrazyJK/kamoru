package com.hs.alice.auth.domain;

// Generated 2013. 4. 16 오후 4:38:05 by Hibernate Tools 3.4.0.CR1

import java.util.Arrays;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.persistence.TableGenerator;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.CascadeType;
import javax.persistence.Transient;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.hs.alice.core.AliceCore;

/**
 * AuthUser generated by hbm2java
 */
@Entity
@Table(name = "AUTH_USER", schema = "ALICE")
//@org.hibernate.annotations.Cache(usage = org.hibernate.annotations.CacheConcurrencyStrategy.READ_WRITE)
public class AuthUser implements java.io.Serializable {

	private static final long serialVersionUID = AliceCore.SERIAL_VERSION_UID;

	private static final Log logger = LogFactory.getLog(AuthUser.class);

	private Integer userid;
	private AuthGroup authGroup;
	private String username;
	private String password;
	private String refkey;
	private Character accountexpired;
	private Character accountlocked;
	private Character passwordexpired;
	private Date passwordexpireddate;
	private Integer passwordfailcount;
	private Date accountexpireddate;
	private Date lastlogindate;
	private Set<AuthRoleUserMap> authRoleUserMaps;

	private Integer[] roles; 
	
	public AuthUser() {
		authRoleUserMaps = new HashSet<AuthRoleUserMap>();
	}

	public AuthUser(Integer userid, String username, String password) {
		this.userid = userid;
		this.username = username;
		this.password = password;
	}

	public AuthUser(Integer userid, AuthGroup authGroup, String username,
			String password, String refkey, Character accountexpired,
			Character accountlocked, Character passwordexpired,
			Date passwordexpireddate, Integer passwordfailcount,
			Date accountexpireddate, Set<AuthRoleUserMap> authRoleUserMaps) {
		this.userid = userid;
		this.authGroup = authGroup;
		this.username = username;
		this.password = password;
		this.refkey = refkey;
		this.accountexpired = accountexpired;
		this.accountlocked = accountlocked;
		this.passwordexpired = passwordexpired;
		this.passwordexpireddate = passwordexpireddate;
		this.passwordfailcount = passwordfailcount;
		this.accountexpireddate = accountexpireddate;
		this.authRoleUserMaps = authRoleUserMaps;
	}

	@Transient
	public Integer[] getRoles() {
		logger.debug(this);
		if(this.authRoleUserMaps != null) {
			roles = new Integer[this.authRoleUserMaps.size()];
			int i=0;
			for(AuthRoleUserMap authRoleUserMap : this.authRoleUserMaps) {
				roles[i++] = authRoleUserMap.getAuthRole().getRoleid();
			}
			logger.debug(Arrays.toString(roles));
			return roles;
		}
		else {
			logger.debug("authRoleUserMaps null");
			return new Integer[0];
		}
	}
	public void setRoles(Integer[] roles) {
		logger.debug(Arrays.toString(roles));
		Set<AuthRoleUserMap> rebuildAuthRoleUserMaps = new HashSet<AuthRoleUserMap>();
		for(Integer roleid : roles) {
			boolean notfound = true;
			// 기존에 가지고 있는지 찾아, 다시 넣어준다.
			for(AuthRoleUserMap authRoleUserMap : this.authRoleUserMaps) {
				Integer rid = authRoleUserMap.getAuthRole().getRoleid();
				if(rid.equals(roleid)) {
					rebuildAuthRoleUserMaps.add(authRoleUserMap);
					notfound = false;
					break;
				}
			}
			// 기존에 없는 것이면, 새로 만들어 넣어준다.
			if(notfound) {
				AuthRole authRole = new AuthRole();
				authRole.setRoleid(roleid);
				AuthRoleUserMap authRoleUserMap = new AuthRoleUserMap();
				authRoleUserMap.setAuthUser(this);
				authRoleUserMap.setAuthRole(authRole);
				
				rebuildAuthRoleUserMaps.add(authRoleUserMap);
			}
		}
		this.setAuthRoleUserMaps(rebuildAuthRoleUserMaps);
		this.roles = roles;
	}
	
	@Id
	@TableGenerator(name="TABLE_GEN", table="ALICE_ID", pkColumnName="ID_NAME", 
		valueColumnName="ID_COUNT", pkColumnValue="AUTH_USER", allocationSize=1)
	@GeneratedValue(strategy=GenerationType.TABLE, generator="TABLE_GEN")
	@Column(name = "USERID", unique = true, nullable = false, precision = 22, scale = 0)
	public Integer getUserid() {
		return this.userid;
	}

	public void setUserid(Integer userid) {
		this.userid = userid;
	}

	@ManyToOne(fetch = FetchType.EAGER)
	@JoinColumn(name = "GROUPID")
	public AuthGroup getAuthGroup() {
		return this.authGroup;
	}

	public void setAuthGroup(AuthGroup authGroup) {
		this.authGroup = authGroup;
	}

	@Column(name = "USERNAME", nullable = false, length = 20)
	public String getUsername() {
		return this.username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	@Column(name = "PASSWORD", nullable = false, length = 100)
	public String getPassword() {
		return this.password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	@Column(name = "REFKEY", length = 100)
	public String getRefkey() {
		return this.refkey;
	}

	public void setRefkey(String refkey) {
		this.refkey = refkey;
	}

	@Column(name = "ACCOUNTEXPIRED", length = 1)
	public Character getAccountexpired() {
		return this.accountexpired;
	}

	public void setAccountexpired(Character accountexpired) {
		this.accountexpired = accountexpired;
	}

	@Column(name = "ACCOUNTLOCKED", length = 1)
	public Character getAccountlocked() {
		return this.accountlocked;
	}

	public void setAccountlocked(Character accountlocked) {
		if(accountlocked == 'F') 
			this.passwordfailcount = 0;
		this.accountlocked = accountlocked;
	}

	@Column(name = "PASSWORDEXPIRED", length = 1)
	public Character getPasswordexpired() {
		return this.passwordexpired;
	}

	public void setPasswordexpired(Character passwordexpired) {
		this.passwordexpired = passwordexpired;
	}

	@Temporal(TemporalType.DATE)
	@Column(name = "PASSWORDEXPIREDDATE", length = 7)
	public Date getPasswordexpireddate() {
		return this.passwordexpireddate;
	}

	public void setPasswordexpireddate(Date passwordexpireddate) {
		this.passwordexpireddate = passwordexpireddate;
	}

	@Column(name = "PASSWORDFAILCOUNT", precision = 22, scale = 0)
	public Integer getPasswordfailcount() {
		return this.passwordfailcount;
	}

	public void setPasswordfailcount(Integer passwordfailcount) {
		this.passwordfailcount = passwordfailcount;
	}

	@Temporal(TemporalType.DATE)
	@Column(name = "ACCOUNTEXPIREDDATE", length = 7)
	public Date getAccountexpireddate() {
		return this.accountexpireddate;
	}

	public void setAccountexpireddate(Date accountexpireddate) {
		this.accountexpireddate = accountexpireddate;
	}
	
	@Temporal(TemporalType.DATE)
	@Column(name = "LASTLOGINDATE", length = 7)
	public Date getLastlogindate() {
		return lastlogindate;
	}

	public void setLastlogindate(Date lastlogindate) {
		this.lastlogindate = lastlogindate;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "authUser", cascade = CascadeType.ALL, orphanRemoval=true)
//	@MapKey(name="authRole")
	public Set<AuthRoleUserMap> getAuthRoleUserMaps() {
		return this.authRoleUserMaps;
	}

	public void setAuthRoleUserMaps(Set<AuthRoleUserMap> authRoleUserMaps) {
		this.authRoleUserMaps = authRoleUserMaps;
	}

	@Override
	public String toString() {
		return "AuthUser [userid=" + userid + ", authGroup=" + authGroup.getGroupid()
				+ ", username=" + username + ", password=" + password
				+ ", refkey=" + refkey + ", accountexpired=" + accountexpired
				+ ", accountlocked=" + accountlocked 
				+ ", passwordexpired=" + passwordexpired 
				+ ", passwordexpireddate=" + passwordexpireddate 
				+ ", passwordfailcount=" + passwordfailcount 
				+ ", accountexpireddate=" + accountexpireddate 
				+ ", lastlogindate=" + lastlogindate 
//				+ ", authRoleUserMaps=" + authRoleUserMaps
				+ "]";
	}

	/**
	 * 실패 횟수 증가시키고, 실패회수가 넘으면 계정 잠금
	 * @param usePasswordFailureCount
	 */
	public void drivePasswordFailure(int maxPasswordFailureCount) {
		this.passwordfailcount++;
		if(this.passwordfailcount >= maxPasswordFailureCount) {
			this.accountlocked = 'T';
		}
	}

	/**
	 * 잠긴 계정을 푼다.
	 */
	public void unlockAccount() {
		this.accountlocked = 'F';
		this.passwordfailcount = 0;
	}
	
	/** 계정 관련 flag를 초기화 한다<br/>
	 * 계정만료, 잠금, 암호 만료, 암호실패횟수
	 */
	public void initializeFlag() {
		this.setAccountexpired('F');
		this.setAccountlocked('F');
		this.setPasswordexpired('F');
		this.setPasswordfailcount(0);
	}
	
	/**
	 * 모든 getter를 호출하여, lazy loading된 데이터를 fetch한다.
	 */
	public AuthUser fetch() {
		this.getAccountexpired();
		this.getAccountexpireddate();
		this.getAccountlocked();
		this.getAuthGroup();
		this.getAuthRoleUserMaps();
		this.getLastlogindate();
		this.getPassword();
		this.getPasswordexpired();
		this.getPasswordexpireddate();
		this.getPasswordfailcount();
		this.getRefkey();
		this.getRoles();
		this.getUserid();
		this.getUsername();
		
		return this;
	}
}
